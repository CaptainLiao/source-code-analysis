>当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。——Vue官网深入响应式系统原理

新世界的大门打开了，欢迎来到`observer`的地盘。

让我们走进`core/observer/index.js`，从中一探数据是如何被观察的。
````
export function observe (value, asRootData){
  let ob
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value)
  }
  if (asRootData && ob) {
    ob.vmCount++
  }
  return ob
}
````
可以看到，`observe(data, true)`返回了一个`Observer`的实例化对象`ob`，此刻，`data`完成了`data -> ob`的神圣转变。接下来，我们看看`ob`也即`new Observer(value)`是个什么东西。

#### Observer 类粉墨登场
*Observer 类对数组和obj采取了不同的策略，简单起见，这里只针对obj类型*
````
export class Observer {
  value: obj;
  dep: Dep;
  vmCount: number; // 根级$data对象的个数

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)
    this.walk(value)
  }
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i], obj[keys[i]])
    }
  }
}
````
`defineReactive`重新定义 obj 的每个key，使之拥有getter和setter方法，在get key时收集依赖，set key时触发更新
````
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  // cater for pre-defined getter/setters
  const getter = property && property.get
  const setter = property && property.set

  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow && observe(newVal)
      dep.notify()
    }
  })
}
````

此时，`data`的每个`key`都被`Observer`转换为一个能够收集依赖和触发更新的getter/setter对象。

**进展小总结**：
`new Vue(opts) -> this._init(opts) -> initState(vm) -> observe(data, ture) -> new Observer(data)`

那么`new Observer(data)`是如何收集依赖和触发更新的呢？在`defineReactive`中，我们发现`dep.depend()`收集依赖，`dep.notify()`依赖更新。



#### 源码及注释：https://github.com/CaptainLiao/source-code-analysis/tree/master/VUE