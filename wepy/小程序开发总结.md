# 野鹅国际票小程序开发总结

和 @徐洋 @张帅 @廖飞银 几位老师一起开发了野鹅国际票的小程序，来分享一下遇到的坑和(未必佳的)解决方案吧。

    不过在此之前，还是学已离场的祝老师，做一下尿性的声明：
    对钟情抄袭/构建私有生态圈的糟心公司的封闭技术毫无好感，也没法欣赏小程序技术之美，仅仅是本着"多数工作都是get shit done"的精神来开发。

小程序提供的开发方式类似vue，接口、概念、工具都比较简单好上手，直接看官方文档就够了。这里聊聊以下话题。


## 1. 项目构建过程

**TL;DR: 没有项目构建过程**

是直接写要提交到商店的源码，还是加入一个构建过程？多数大公司的项目看起来选择了后者。

但考虑到多数js项目需要“构建”的方面，小程序的编辑器都已经集成解决了：

- wxml压缩
- es6支持
- js压缩
- wxss增加浏览器前缀
- 监控重载

出于降低工程复杂性的考虑，没有引入构建（推锅：是@zhangshuai的意见，哈哈）。目前只遇到少数痛点，解决起来成本还不算太高：

- png压缩 --> 少数图片手动上传tinypng.com压缩，然后入库或cdn
- es6 polyfill  --> 手动在代码开始处引入polyfill
- css -> 只能手写，正好对嵌套层级过深的问题提高警惕 (less/sass也是比较有争议性的技术)
- 组件化 --> 得自己实现一个运行时的组件化机制

总的来说：引入构建是以增加复杂度为代价来增加灵活性，可以解决很多现有问题和未来的问题，是一个可以权衡的选择。
[pinche小程序](http://gitlab.huolih5.com/wx-app/pinche)使用了wepy框架，感觉[很不错](http://gitlab.huolih5.com/hangban/team-wiki/wikis/project/wxapp/wepy)。

## 2. 状态管理

**TL;DR: 页面状态外置，添加redraw()方法**

小程序的接口设计中，读一个页面的状态，可以用`页面实例.data`；但是写页面状态，要调用`页面实例.setData(key, value)`。直接写`this.data`无法提交更改也不会触发视图刷新。

不能直接操纵这个数据会带来诸多不便。(React也只有setState，结果引来了flux/redux等一堆状态管理库，何苦)

出于这样的缘由，国际票小程序将页面状态外置，也就是使用另一个对象（用页面实例的属性还是闭包变量并不重要，总之它不是this.data），并新增了一个redraw()函数(名称抄自mithril.js)，来触发`外置状态 =>页面渲染`，代码大概是这样:

```js
// pageA.service.js
// 外置的页面状态和操作状态的方法, deadly simple
const pageData = {
    goal: { screw: 'tencent' },
    fetchNewGoal(){
       return fetch().then(goal => this.goal = goal)
    },
    load(){
       wx.navigateTo({ url: '/pageA' })
    }
}


// pageA.js
const P = require('./pageA.service.js')
let redraw = () => {}  // redraw得等到生成页面实例时才能获得定义

Page({
    data: { P },
    onLoad(){
       redraw = () => this.setData({ P })   // 定义
    },
    onShow(){ 
       redraw()   // 在发生状态改变或其他需要渲染的时机，手动redraw()
    }
})

```

现在，我们背离了小程序官方的设计思路，用了它不提倡的方法。这种反叛很显然~~会被诅咒~~是有成本的：

- 状态的存储增加了一次中转
- 更改状态后要手动redraw()
- redraw更改状态是全量更新的，每一次setData()都是按最大数据量传输，对渲染性能不利 <small> （真的是这样么? 看后文）</small>

那么这样有什么好处呢？好处在于，状态是个我们自己维护的plain object，我们可以获得操作plain object的所有便利：

- 在读写外置的状态时，享受编辑器的自动补全/定义跳转；如果上了TypeScript等静态类型语言, 还可以轻易加上静态类型检查，变量重命名也是安全的。
- 可以用熟悉的/简单的方式操作状态
	- 假设在操作一个层级很深的属性，我们只需要就地更改这个属性然后重绘： `fly.selected = true; redraw();` 。而用官方的setData, 只能手动构建这个更新: `this.setData('myData.orders.flights.fly[6].selected', true)`，拼这个坑爹的字符串时，编辑器完全帮不上你，后续的重构更会让人笑不出来。
	- 可以批量修改后再redraw()
	- 可以用"就地更改"的一些方法，`[].splice()`，`Object.assign` 等
- 支持灵活地划分、管理状态
	- 可以将状态按领域模型划分（比如一个页面使用Order, User等多个领域模型，各模型具备操纵/更新自己的方法）
	- 支持多个页面共用一个模型（如多个小程序页面共用一个User模型，在一个页面登陆获得用户信息后，其他页面无需做任何操作就能显示最新状态）
- 支持"页面即服务"的模式。如果A页面需要调用B页面，获得B页面的操作结果，我们仅需要在A页面调用 `bPageService.load({ param1:value1, onDone: result => doWhatever(result) })` 。这样，B页面就像是一个普通的异步函数，我们传入参数和回调，监听结果，直观清晰。作为对比，用URL的方式只能传入简单的参数，不能传function/array等复杂参数，为了达到类似功能，我们只能绕着弯解决。
- 更容易支持下面会提到的组件化方案
- 更容易性能优化 —— 很快就能发现，我们并不需要天真的`setState`全部状态，下面的性能优化会详细说明

## 3. 组件化方案

**TL;DR: 我们写了一个20行的函数**

小程序到目前为止还没有给出很好的组件化解决方案（虽然有消息说新版本会提供方案支持），大家只能自己撸一个。

因为我们没有代码编译环节，所以组件化必须在运行时实现。期望至少实现：
- 一个页面同时存在有同类组件的多个实例
- 组件可以有自己的状态和方法
- 组件支持嵌套 （所以组件的状态也要支持嵌套）
- ~~最好支持高阶组件~~ （搞不定）

分析一下小程序现有框架对组件的支持情况：
- wxml： OK， 支持模板`<template>`，也支持模板引用其他模板  
- wxss： OK， 支持`@includes`其他样式，也支持嵌套引用
- js: FAIL， 在状态外置之后，页面状态可以嵌套包含其他对象，但是子对象的方法没有暴露在页面实例上，不能被页面模版访问 (在`bindXXX`时，wxml只认页面存在于实例上方法) 

所以，为了支持组件化，我们只需补上缺少的这一环。

野鹅国际票选取了一种最小的实现(`registerMethod.js`)，它将一个对象(组件实例)的所有方法，通过方法名的方式关联到另一个对象(页面实例或父组件)上。在一级级关联之后，页面就包含了各子/孙组件的全部状态和方法，而且各方法都能够被wxml正确访问，同时方法名不冲突。

具体可以看`home.js`(首页)中调用`snackbar.js`(底栏通知组件)的代码。

嵌套组件的示例可以看`pay.js`(支付页)调用`component/pay.js`(支付模块)，再调用`snackbar.js`

不能说现在的实现方式有什么特别的优越性，但是已经能达到上面列出的需求。同时实现和概念都相对简单（~20行代码），足够使用。

值得说明的是，如果没有上面实施的外置状态，组件化就没有办法这么容易地实现了。


## 4. 兼容性

**TL;DR: 小程序说解决了兼容性问题都是骗人的**

开发小程序需要关注的兼容性问题和开发web差不多：ES6，CSS，~~DOM~~小程序SDK。
这里汇总一下在iOS 8上已知并解决的兼容性问题。

小程序SDK：
- 根据要支持的用户范围，确定可以使用的最高SDK版本。同时：
   - 尽可能避免因为使用新接口而导致用低版本SDK的用户无法完成操作
   - 可以在应用启动时检查版本支持情况，提示用户，对不支持的接口打补丁
- wx.canIUse比较鸡肋(会误报/用不了)，最好用 `typeof wx[method] === 'function'`手动检查

ES6：
- 根据操作系统和微信版本的不同，小程序内部使用了不同的JS引擎，ES6支持程度不一
- 小程序编辑器会做ES6语法转换
- ES6新增的方法还是需要自己polyfill （比如`Object.assign`, `Array.prototype.find`)
- Promise是坑，iOS 8上有Promise的对象和方法定义，但是`.then()`不会被调用。所以还是要带上自己的Promise polyfill. 

WXSS
- `.wxss`中的浏览器兼容前缀，小程序编辑器可以自动添加
- 用style来控制样式时，某些属性需要记得自己加前缀（如`transform` => `-webkit-transform`）
- 高版本CSS特性，在iOS 8等低版本系统上不支持（如`calc()`)


## 5. 性能优化

**TL;DR: 减少渲染节点的数量，减少setData()传输量**

*把性能排在最后，并非性能不重要，而是性能需要在最后再来优化。如果开始时过多考虑性能问题，我们很有可能拿不出好方案。*

用较早的设备（iPhone 5）打开元素较多的页面（如日期选择页）时，发现操作存在明显的延时。更令人无法接受的是，同类小程序的同类页面几乎无卡顿……我们必须为荣誉而战。 

优化首先要确定衡量标准，才能确定优化措施是否有效。小程序提供了性能面板，可以清楚地显示每一次重绘的耗时，而小程序SDK v1.5.2又新增了一个setData()的回调参数，可以用来打印从setData()到绘制完成的消耗时间。

参照这两个数据，我们尝试了下面的优化措施：

### 5.1 减少setData()的传输量【有效】

这是官方的[优化建议](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/performance/tips.html)的第一条，没有理由不优先尝试。

前面提到我们setData()都是在redraw()函数中自动执行的，且会全量更新，听起来非常的低效。不过，这里留下了很大的优化空间：我们可以通过比对上一次的页面状态(this.data)，来获得最小的更新量(update)。相比每一次修改状态时小心翼翼地去控制setData()的范围，我们现在仅仅需要写一个方法来生成update，就一劳永逸地完成了这个优化工作，还能保证其效果基本是最优的。

`diff.js`就是用来生成这个update的，它由两部分组成：

1. **diff**：计算两个对象的差异量，结果用一个object来表示，object的每个字段进一步记录两个对象的这个字段值diff的结果。
2. **flatten**: 将上一步的diff object转换成`setData()`接受的update形式: `{ [keyPath]: value }`。diff object可能有较深的层级，需要将其“扁平化”。

计算diff时有一个值得一提的地方，就是我们发现有必要区分一个字段值是“新生成的”还是“修改后的”。如果能够知道是新生成的，我们最好在**flatten** 时，生成这样的结果：

```js
{
  'a.b.c[5]': { x: 1, y: 2,z: 3 }
}
```

而不是这样的结果：

```js
{
  'a.b.c[5].x': 1,
  'a.b.c[5].y': 2,
  'a.b.c[5].z': 3
}
```

后者很明显传输量更大，小程序内部解析起来效率也会更低。

那么，如何确定一个字段值是新增的还是修改的？对于对象的字段值来说，这个很明显，从null/undefined变成object就是新增的，否则就是修改的；但对于数组来说，我们就需要用别的方式来判断，比如比对key、id等。

在diff过后，我们现在确实能拿到一个最小的update了。但是有一个问题：diff本身不会损害性能么？将整个页面数据逐个字段比对，一定非常耗时吧？我们观察到的结果是：相比于节省传输量得到的优化效果，diff基本不怎么耗时(渲染时间的1/10以内)，简单的说就是非常合算。当然diff的实现本身也可以继续优化，但是除非有很好的理由，不然就这样也足够了。

在采用diff的方法后，渲染耗时在某些情况下大约下降1/3左右。

### 5.2 减少显示节点的数量【非常有效】

减少显示节点会加速渲染么？我们做了一个简单的实验，将日历展示范围从12个月减至6个月，渲染时间基本上减少了一半。线性关系是最朴实的关系。那么我们来减少节点数量吧。

日历页最多的元素是日期(天)，我们应该且只应该从它下手。原本为了显示一个日期，奢侈地用了6个节点：`日期容器view> 日期text+航班价格text+是否直飞text+选中的蓝灰色高亮view+途经选中的浅灰色高亮view` 。为了减少节点，我们发动奇巧淫技，用`background: linear-gradient()`重新实现了各情况下的高亮效果(~~同时去掉了过渡的动效~~)。

在去掉了2个高亮效果的view和日期text，由6个节点变为3个之后。基本上日历页点击不再有可感知的卡顿了。hooray!

剩下的是几项效果没有太明显的措施。

### 5.3 其他优化措施

- 减少模版(wxml)中的条件判断逻辑，用js提前计算好
- 减少动画

在实施了以上优化措施后，原本卡出翔的日历页，现在明显比“同类小程序的同类页面”响应还要快速，真理站在了正义的一方，胸前的红领巾红艳艳。


## 6. 总结

状态外置是个有点大胆的做法，但是它给状态管理、组件化甚至性能优化都带来了好处。如果要说从中得到什么信息/经验的话，还是[那句话](https://en.wikipedia.org/wiki/Indirection)：

    All problems in computer science can be solved by another level of indirection

但是怎样增加"another level of indirection"来"solve all problems"，而不是堆叠无意义的复杂度，依然是值得思考的问题。

开发过程中有一处比较有意思的需求，就是设计师提出需要实现：小飞机在云朵上漂浮的加载动画。
云朵不停向下移动，比较简单就不说了。小飞机的运动轨迹类似五叶草的轮廓线。最终采用了一个非常取巧的方式实现，效果还不错。大家可以猜猜怎么做。

小程序本身没有什么可说的，开发完成后运行性能比H5好。开发过程中，最大的槽点是基于模版的视图系统。一方面需要学习毫无意义的DSL，一方面就算学过了，能实现的东西还是比有完整js能力的virtual dom弱太多，衍生状态/高阶组件……都很难/无法实现。hackernews上有位用户的[吐槽](https://news.ycombinator.com/item?id=15199879)很毒：

`All that matters is Angular and Vue are based on the outmoded logic-in-HTML paradigm.`

